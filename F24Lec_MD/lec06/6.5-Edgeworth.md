---
title: "6.5-Edgeworth"
type: lecture-notebook
week: 6
source_path: "/Users/ericvandusen/Documents/Data88E-ForTraining/F24Lec_NBs/lec06/6.5-Edgeworth.ipynb"
---

## Edgeworth Box Demo
### as another application of Cobb-Douglas Utility Function


The code is taken from "Gaby Galvan" 
https://deepnote.com/app/gaby-galvan/Edgeworth-Box-5c892517-cb51-4f3f-b20d-8e5dd8b5ac46

```python
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
```

```python
out = 0
```

### Overview of the Edgeworth Box

An **Edgeworth box** is a graphical representation used in microeconomics to illustrate the distribution of resources (goods) between two consumers in a simple exchange economy. It shows all possible allocations of two goods between two consumers and helps analyze their preferences, trade possibilities, and potential for reaching Pareto-efficient outcomes.

In your scenario:

- **Two Consumers**: The consumers are trading Noodles and Cereal.
- **Objective**: To visualize how these consumers can trade to reach mutually beneficial (Pareto-efficient) allocations based on their utility preferences.

---

### Key Components of the Code

Let’s break down the main elements of your code to understand how it represents the economic concepts:

#### 1. Utility Functions (`U1` and `U2`)

- **Purpose**: Represent the satisfaction (utility) each consumer derives from consuming Noodles (X) and Cereal (Y).
- **Form**: Must be functions of two variables, e.g., `U1(x, y)` and `U2(x, y)`.
- **Interpretation**: The shape of the utility functions reflects each consumer's preferences and marginal rates of substitution (MRS) between Noodles and Cereal.

#### 2. Edgeworth Box Dimensions (`Xmax`, `Ymax`, `Xmin`, `Ymin`)

- **`Xmax` and `Ymax`**: Total available quantities of Noodles and Cereal in the economy.
- **`Xmin` and `Ymin`**: Set close to zero to avoid computational issues with logarithmic utilities or division by zero.
- **Interpretation**: The box's dimensions represent the entire feasible set of allocations between the two consumers.

#### 3. Indifference Curves

- **Definition**: Curves along which a consumer derives the same level of utility.
- **Implementation**: The code uses `plt.contour()` to draw these curves for both consumers.
- **Economic Intuition**:
    - **Consumer 1**: Indifference curves are plotted from the origin at (0,0).
    - **Consumer 2**: Indifference curves are plotted from the opposite corner (Xmax, Ymax), reflecting that any consumption by Consumer 1 reduces the amount available to Consumer 2.

#### 4. Contract Curve

- **Definition**: The set of allocations where the indifference curves of the two consumers are tangent—i.e., where their MRS are equal.
- **Implementation**:
    - Calculated by finding where the gradients of the utility functions are proportional.
    - The code computes gradients using `np.gradient()` and identifies where the determinant of the Jacobian (`out`) is zero.
    - Plotted using `plt.contour()` with specific levels.
- **Economic Intuition**: Represents all Pareto-efficient allocations—no consumer can be made better off without making the other worse off.

#### 5. Allocation Point (`AlPoint`)

- **Purpose**: Represents a specific allocation of Noodles and Cereal between the two consumers.
- **Usage**:
    - If provided, the code plots this point and the corresponding indifference curves passing through it for both consumers.
    - Helps visualize the initial endowment and potential gains from trade.
- **Economic Intuition**: Demonstrates how consumers can move from an initial allocation to a Pareto-efficient allocation through mutually beneficial trade.

#### 6. Utility Levels and Number of Indifference Curves (`Utility_Show`, `Num_ind`)

- **`Utility_Show`**: When `True`, displays utility levels on the indifference curves.
- **`Num_ind`**: Controls the number of indifference curves plotted for each consumer.
- **Economic Intuition**: More curves provide a detailed view of preferences but may clutter the graph; adjusting `Num_ind` balances detail and clarity.

#### 7. Other Parameters

- **Labels (`Xlab`, `Ylab`)**: Axis labels for clarity—here, they should be set to "Noodles" and "Cereal."
- **Colors (`colors`)**: Customize the appearance of the plot elements for better distinction.
- **Endowment (`e`)**: Number of steps used in calculations—higher values lead to smoother curves but increase computation time.

---

### Economic Intuition Behind the Code

#### Mutually Beneficial Trade

- **Starting Point**: Consumers begin with an initial allocation of Noodles and Cereal.
- **Objective**: Through trade, both aim to reach higher indifference curves, thus achieving higher utility levels.
- **Visualization**: The movement from the initial allocation point towards the contract curve represents this process.

#### Marginal Rate of Substitution (MRS)

- **Definition**: The rate at which a consumer is willing to trade one good for another while maintaining the same utility level.
- **Equal MRS**: At points on the contract curve, both consumers have equal MRS, meaning they value the trade-off between Noodles and Cereal equally.
- **Economic Intuition**: Equating MRS ensures that resources are allocated efficiently between the two consumers.

#### Pareto Efficiency

- **Definition**: An allocation is Pareto-efficient if no consumer can be made better off without making the other worse off.
- **Contract Curve**: All points along this curve are Pareto-efficient allocations.
- **Visualization**: The contract curve in the Edgeworth box shows all such allocations.

#### Utility Maximization

- **Consumers' Goal**: Each aims to reach the highest possible indifference curve given their budget constraints (the total available goods).
- **Constraints**: Limited by the total quantities of Noodles and Cereal in the economy.
- **Trade-Offs**: Consumers make choices based on their preferences, as depicted by the shapes of their indifference curves.


### Interpreting the Graph

#### Axes

- **Horizontal Axis**: Quantity of Noodles consumed by Consumer 1 (Alice).
- **Vertical Axis**: Quantity of Cereal consumed by Alice.
- **Origin for Consumer 2 (Bob)**: Located at the top-right corner

```python
 
def draw_Ed_Bow(U1,U2, Xmax, Ymax, Xmin=10**(-6), Ymin=10**(-6), Utility_Show = False, Num_ind = 10,Xlab ="X",Ylab="Y",e=200, Contract_draw=True,AlPoint = None,colors =["black","Orange", "blue","red"],Utility_draw = True):
    """
    Input : 
        U1: Utility of the 1st agent (must depend on 2 variables)
        U2: Utility of the 2nd agent (must depend on 2 variables)
        Xmax : the limit of the box
        Ymax: the limit of the box
        Xmin=10**(-6): the limit of the box (default: set to ~0 to avoid problems with log expressions)
        Ymin=10**(-6): the box limit (default: set to ~0 to avoid problems with log expressions)
        Utility_Show = False: Show utility levels on the Edgeworth box
        Num_ind = 10 : Number of indifference curves per agent
        e = 200 : Number of steps to compute the utility levels and the contract curve
        Contract_draw = True: Draw the contract curve 
        AlPoint = None : show an allocation point and his 2 indifference curves. Should be a tuple/list (x,y)
        colors = ["black","Orange", "blue","red"] : To choose the color of : [ContractCurve, endowment point, indifference curves Agent1, indifference curves agent2]
        Utility_draw = True : Draw the indefrence curves
    Output:
        None (but draws the Edgeworth box) 
    """
    delta = min((Xmax-Xmin)/e,(Ymax-Ymin)/e)

    x = np.arange(Xmin, Xmax, delta) #Tomates
    y = np.arange(Ymin, Ymax, delta) #courgettes
    X, Y = np.meshgrid(x, y)
    Z1 = lambda x,y : U1(x,y)
    Z2 = lambda x,y : U2(Xmax-x,Ymax-y)

    #the contract curve
    Num_ind_1 = Num_ind
    Num_ind_2 = Num_ind

    if Contract_draw == True:
        Z2grad = np.gradient(Z2(X,Y))
        Z1grad = np.gradient(Z1(X,Y))

        global out
        out = (Z2grad[0]*Z1grad[1]-Z2grad[1]*Z1grad[0])

        Cont = plt.contour(X,Y,out,colors=colors[0],levels=[0])
        fmt = {}
        strs = ["Contract  curve"]
        for l, s in zip(Cont.levels, strs):
            fmt[l] = s
        plt.clabel(Cont, Cont.levels, inline = True,
                fmt = fmt, fontsize = 10)
        
        C_curv = abs(pd.DataFrame(out ,index=y, columns=x))
        C_curv = C_curv.index @ (C_curv == C_curv.apply(min))
        xC_curv = np.arange(Xmin,Xmax,(Xmax-Xmin)/(Num_ind+1))
        C_curv = np.interp(xC_curv,C_curv.index,C_curv)
        Num_ind_1 = pd.Series(Z1(xC_curv,C_curv)).sort_values(ascending=True)
        Num_ind_2 = pd.Series(Z2(xC_curv,C_curv)).sort_values(ascending=True)
        
    #Draw the dotation point and his curves
    if AlPoint != None:
        plt.scatter(AlPoint[0],AlPoint[1],s=200,marker=".",color = colors[1],label="Allocation point")
        Num_ind_1 = [Z1(AlPoint[0],AlPoint[1])]
        Num_ind_2 = [Z2(AlPoint[0],AlPoint[1])]

    #draw the indifference curve
    if Utility_draw == True:
        C1 = plt.contour(X, Y, Z1(X,Y),colors = colors[2],levels=Num_ind_1)
        C2 = plt.contour(X, Y, Z2(X,Y),colors = colors[3],levels=Num_ind_2)
        if Utility_Show == True:
            fmt = {}
            strs = round(pd.Series(C1.levels[:]),1)
            for l, s in zip(C1.levels, strs):
                fmt[l] = s
            plt.clabel(C1, C1.levels, inline = True,
                    fmt = fmt, fontsize = 10)
            #Utility level2

            fmt = {}
            strs = round(pd.Series(C2.levels[:]),1)
            for l, s in zip(C2.levels, strs):
                fmt[l] = s
            plt.clabel(C2, C2.levels, inline = True,
                    fmt = fmt, fontsize = 10)


    plt.title("Edgeworth box")
    plt.xlabel(Xlab)
    plt.ylabel(Ylab)
```

## We can then set the parameters for Alpha and Beta in the Cobb - Douglas formula

##  Let's consider the simpler case of a Utility function 
- that has a Cobb-Douglas type formulation 
- consists of consuming two goods $X1$ and $X2$

$  U = \cdot X1^{\alpha} \cdot X2^{1-\alpha}$

```python
#Utility of 1st agent (depend on X,Y):
U1 = lambda c,n : c**0.5 * n**0.5
#Utility of 2nd agent (depend on X,Y):
U2 = lambda c,n : c**0.5 * n**0.5


draw_Ed_Bow(U1,U2,18,30,colors=["k","Orange", "lightblue","mistyrose"],Num_ind=3)
draw_Ed_Bow(U1,U2,18,30,Xlab="Cereal",Ylab="Noodles",AlPoint=(10,16),Contract_draw=False)
plt.show()
```

```python
#Utility of 1st agent (depend on X,Y):
U1 = lambda c,n : c**0.7 * n**0.3
#Utility of 2nd agent (depend on X,Y):
U2 = lambda c,n : c**0.5 * n**0.5


draw_Ed_Bow(U1,U2,18,30,colors=["k","Orange", "lightblue","mistyrose"],Num_ind=3)
draw_Ed_Bow(U1,U2,18,30,Xlab="Cereal",Ylab="Noodles",AlPoint=(11.5,13),Contract_draw=False)
plt.show()
```

## General parameters for $\alpha $ and $ \beta $

```python
alpha1 = 0.5
beta1 = 0.5
alpha2 = 0.7
beta2 = 0.3
```

```python
#Utility of 1st agent (depend on X,Y):
U1 = lambda c,n :n**alpha1 * c**beta1
#Utility of 2nd agent (depend on X,Y):
U2 = lambda c,n : n**alpha2 * c**beta2


draw_Ed_Bow(U1,U2,30,18,colors=["k","Orange", "lightblue","mistyrose"],Num_ind=3)
draw_Ed_Bow(U1,U2,30,18,Xlab="Cereal",Ylab="Noodles",AlPoint=(18,7),Contract_draw=False)
plt.show()
```

```python

```

